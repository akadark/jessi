package entity;

import java.util.*;

import javax.swing.*;

import valueObject.*;

public class Recipe {
  private Vector<RecipeInfo> recipelist;
  private Vector<RecipeInfo> likelist;
  private Vector<RecipeInfo> resultlist;
  private Vector<String> ingredientlist1;
  private Vector<String> ingredientlist2;
  private Vector<String> ingredientlist3;
  private Vector<String> ingredientlist4;

  SearchRecipe hashmap;

  public Recipe() {// 생성시 레시피 별 재료리스트 추가
    this.recipelist = new Vector<RecipeInfo>();
    this.resultlist = new Vector<RecipeInfo>();
    this.ingredientlist1 = new Vector<String>();
    this.ingredientlist2 = new Vector<String>();
    this.ingredientlist3 = new Vector<String>();
    this.ingredientlist4 = new Vector<String>();
    
    ingredientlist1.add("햄");
    ingredientlist1.add("돼지고기");
    ingredientlist1.add("소시지");
    ingredientlist1.add("양파");
    ingredientlist1.add("고추장");
    
    ingredientlist2.add("연근");
    ingredientlist2.add("간장");
    ingredientlist2.add("식초");
    ingredientlist2.add("물엿");
    
    ingredientlist3.add("낙지");
    ingredientlist3.add("양배추");
    ingredientlist3.add("양파");
    ingredientlist3.add("당근");
    
    ingredientlist4.add("배추");
    ingredientlist4.add("고추가루");
    ingredientlist4.add("소금");
    
    recipelist.add(new RecipeInfo("부대찌개", 5, ingredientlist1));
    recipelist.add(new RecipeInfo("연근조림", 4, ingredientlist2));
    recipelist.add(new RecipeInfo("낚지볶음", 4, ingredientlist3));
    recipelist.add(new RecipeInfo("배추김치", 3, ingredientlist4));
    
  }

  public void initialize(SearchRecipe hashmap){
//    this.hashmap = hashmap;
    hashmap.setRecipeNameInHashmap(1, "부대찌개");
    hashmap.setRecipeNameInHashmap(2, "연근조림");
    hashmap.setRecipeNameInHashmap(3, "낚지볶음");
    hashmap.setRecipeNameInHashmap(4, "배추김치");
  }
  
  // selectlist와 recipelist의 재료 일치를 비교하고 새로운 배열을 만들어 리턴.
  public Vector<RecipeInfo> search(Vector<IngredientInfo> selectlist){
    for(int i = 0; i < recipelist.size(); i++){ // 이전에 검색된 카운트 초기화
      recipelist.get(i).setCount(0);
    }
    
    int k = 0;
    Vector<RecipeInfo> templist = new Vector<RecipeInfo>();
    System.out.println("선택하신 재료 수는 : " + selectlist.size());
    System.out.println("전체 레시피DB 갯수는 : " + recipelist.size());
    for(int i = 0; i < selectlist.size(); i++){
      for(int j = 0; j < recipelist.size(); j++){
        for(k = 0; k < recipelist.get(j).getIngredient().size(); k++){
          //System.out.println(recipelist.get(j).getIngredient().size());          
          if(selectlist.get(i).getIngredientName().equals(recipelist.get(j).getIngredient().get(k))){
            if(recipelist.get(j).getCount() == 0){ // 일치하고 아직 선택된적이 없으면 해당 recipe를 templist에 추가
              templist.add((recipelist.get(j))); 
              System.out.println("일치 레시피 명 : " + recipelist.get(j).getRecipeName() + ",  일치 재료 명" + " : " + recipelist.get(j).getIngredient().get(k));
            }
            recipelist.get(j).countUp(); // 해당 recipe의 count++
          }
        }
        k = 0;
      }
    }
//    for(int a = 0; a < recipelist.size(); a++){ // test
//      System.out.println(a + "번째 레시피의 count : " + recipelist.get(a).getCount());
//    }
    return resultlist = templist; // 최종 resultlist를 새로 만들어진 templist로 교체
  }
  
  public int getLikelist(){ // 좋아요가 1이상인 list에 레시피인포 생성
    // test
	  recipelist.get(0).setLike(4); 
	  recipelist.get(1).setLike(5);
	  recipelist.get(2).setLike(1);
	  recipelist.get(3).setLike(7);
	  
	  System.out.println("recipelist size print : " + recipelist.size());
	  
	  this.likelist = new Vector <RecipeInfo>(); 
	  
	  for(int x = 0; x < recipelist.size(); x++){
		  if(recipelist.get(x).getLike()!=0){ // list에 좋아요가 0이 아닌 리스트를 넣는다
			  likelist.add(recipelist.get(x));
			  System.out.println("likelist "+ x + " print : " + likelist.size());
		  }
	  }
	  return likelist.size(); // 생성된 리스트의 컴포넌트 수를 반환
  }
  
  public Vector<RecipeInfo> sortLike(JTable table){
    getLikelist(); // 테스트용
    quickSort(likelist, 0, likelist.size()-1 );
    return likelist;

 }
  /*
  void bubbleSort(Vector<RecipeInfo> likelist) {

	    int n = likelist.size();
	    Vector<RecipeInfo> temp = new Vector<RecipeInfo>();

	    for (int i = 0; i < n-1; i++) {
	        for (int j = 1; j < (n - i); j++) {

	            if (likelist.get(j-1).getLike() < likelist.get(j).getLike()) {
	            	temp.add(0, likelist.get(j-1));
	            	likelist.set(j-1, likelist.get(j));
	            	likelist.set(j, temp.get(0));
	            }

	        }
	    }
	}
  
  */
  
  
  int partition(Vector<RecipeInfo> likelist, int left, int right)
  {
        int i = left, j = right;
        int middle = left + (right - left) /2;
        Vector<RecipeInfo> temp = new Vector<RecipeInfo>();
        int pivot = likelist.get(middle).getLike();
       
        while (i <= j) {
              for (;likelist.get(i).getLike() > pivot;)
                    i++;
              for (;likelist.get(j).getLike() < pivot;)
                    j--;
              if (i <= j) {
            	  temp.add(0, likelist.get(i));
            	  likelist.set(i, likelist.get(j));
            	  likelist.set(j, temp.get(0));
                    i++;
                    j--;
              }
        };
       
        return i;
  }
   
  void quickSort(Vector<RecipeInfo> likelist, int left, int right) {
        int index = partition(likelist, left, right);
        if (left < index - 1)
              quickSort(likelist, left, index - 1);
        if (index < right)
              quickSort(likelist, index, right);
  }

  
  
 
 }


